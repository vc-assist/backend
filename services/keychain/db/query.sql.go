// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createOAuth = `-- name: CreateOAuth :exec
insert into OAuth(namespace, id, token, email, refresh_url, client_id, expires_at) values (?, ?, ?, ?, ?, ?, ?)
on conflict do update set
    token = EXCLUDED.token,
    email = EXCLUDED.email,
    refresh_url = EXCLUDED.refresh_url,
    client_id = EXCLUDED.client_id,
    expires_at = EXCLUDED.expires_at
`

type CreateOAuthParams struct {
	Namespace  string
	ID         int64
	Token      string
	Email      string
	RefreshUrl string
	ClientID   string
	ExpiresAt  int64
}

func (q *Queries) CreateOAuth(ctx context.Context, arg CreateOAuthParams) error {
	_, err := q.db.ExecContext(ctx, createOAuth,
		arg.Namespace,
		arg.ID,
		arg.Token,
		arg.Email,
		arg.RefreshUrl,
		arg.ClientID,
		arg.ExpiresAt,
	)
	return err
}

const createSessionToken = `-- name: CreateSessionToken :exec
insert into SessionToken(token, OAuthId, UsernamePasswordId) values (?, ?, ?)
on conflict do nothing
`

type CreateSessionTokenParams struct {
	Token              string
	Oauthid            sql.NullInt64
	Usernamepasswordid sql.NullInt64
}

func (q *Queries) CreateSessionToken(ctx context.Context, arg CreateSessionTokenParams) error {
	_, err := q.db.ExecContext(ctx, createSessionToken, arg.Token, arg.Oauthid, arg.Usernamepasswordid)
	return err
}

const createUsernamePassword = `-- name: CreateUsernamePassword :exec
insert into UsernamePassword(namespace, id, username, password) values (?, ?, ?, ?)
on conflict do update set
    username = EXCLUDED.username,
    password = EXCLUDED.password
`

type CreateUsernamePasswordParams struct {
	Namespace string
	ID        int64
	Username  string
	Password  string
}

func (q *Queries) CreateUsernamePassword(ctx context.Context, arg CreateUsernamePasswordParams) error {
	_, err := q.db.ExecContext(ctx, createUsernamePassword,
		arg.Namespace,
		arg.ID,
		arg.Username,
		arg.Password,
	)
	return err
}

const deleteOAuthBefore = `-- name: DeleteOAuthBefore :exec
delete from OAuth where expires_at < ?
`

func (q *Queries) DeleteOAuthBefore(ctx context.Context, expiresAt int64) error {
	_, err := q.db.ExecContext(ctx, deleteOAuthBefore, expiresAt)
	return err
}

const findEmailFromOauthId = `-- name: FindEmailFromOauthId :one
select email from OAuth where id = ?
`

func (q *Queries) FindEmailFromOauthId(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, findEmailFromOauthId, id)
	var email string
	err := row.Scan(&email)
	return email, err
}

const findIdFromOAuthToken = `-- name: FindIdFromOAuthToken :one
select id from OAuth where token = ?
`

func (q *Queries) FindIdFromOAuthToken(ctx context.Context, token string) (int64, error) {
	row := q.db.QueryRowContext(ctx, findIdFromOAuthToken, token)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findIdFromUsername = `-- name: FindIdFromUsername :one
select id from UsernamePassword where username = ?
`

func (q *Queries) FindIdFromUsername(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRowContext(ctx, findIdFromUsername, username)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findSessionToken = `-- name: FindSessionToken :one
select token, oauthid, usernamepasswordid from SessionToken where token = ?
`

func (q *Queries) FindSessionToken(ctx context.Context, token string) (SessionToken, error) {
	row := q.db.QueryRowContext(ctx, findSessionToken, token)
	var i SessionToken
	err := row.Scan(&i.Token, &i.Oauthid, &i.Usernamepasswordid)
	return i, err
}

const getOAuth = `-- name: GetOAuth :one
select token, refresh_url, client_id, expires_at from OAuth where
namespace = ? and id = ?
`

type GetOAuthParams struct {
	Namespace string
	ID        int64
}

type GetOAuthRow struct {
	Token      string
	RefreshUrl string
	ClientID   string
	ExpiresAt  int64
}

func (q *Queries) GetOAuth(ctx context.Context, arg GetOAuthParams) (GetOAuthRow, error) {
	row := q.db.QueryRowContext(ctx, getOAuth, arg.Namespace, arg.ID)
	var i GetOAuthRow
	err := row.Scan(
		&i.Token,
		&i.RefreshUrl,
		&i.ClientID,
		&i.ExpiresAt,
	)
	return i, err
}

const getOAuthBefore = `-- name: GetOAuthBefore :many
select namespace, id, token, email, refresh_url, client_id, expires_at from OAuth where expires_at < ?
`

func (q *Queries) GetOAuthBefore(ctx context.Context, expiresAt int64) ([]OAuth, error) {
	rows, err := q.db.QueryContext(ctx, getOAuthBefore, expiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OAuth
	for rows.Next() {
		var i OAuth
		if err := rows.Scan(
			&i.Namespace,
			&i.ID,
			&i.Token,
			&i.Email,
			&i.RefreshUrl,
			&i.ClientID,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsernamePassword = `-- name: GetUsernamePassword :one
select username, password from UsernamePassword where
namespace = ? and id = ?
`

type GetUsernamePasswordParams struct {
	Namespace string
	ID        int64
}

type GetUsernamePasswordRow struct {
	Username string
	Password string
}

func (q *Queries) GetUsernamePassword(ctx context.Context, arg GetUsernamePasswordParams) (GetUsernamePasswordRow, error) {
	row := q.db.QueryRowContext(ctx, getUsernamePassword, arg.Namespace, arg.ID)
	var i GetUsernamePasswordRow
	err := row.Scan(&i.Username, &i.Password)
	return i, err
}
