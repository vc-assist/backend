// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createOrUpdateKnownCourse = `-- name: CreateOrUpdateKnownCourse :exec
insert into KnownCourse(guid, name, period, teacherFirstName, teacherLastName, teacherEmail, room)
values (?, ?, ?, ?, ?, ?, ?)
on conflict (guid)
    do update set
        guid = EXCLUDED.guid,
        name = EXCLUDED.name,
        period = EXCLUDED.period,
        teacherFirstName = EXCLUDED.teacherFirstName,
        teacherLastName = EXCLUDED.teacherLastName,
        teacherEmail = EXCLUDED.teacherEmail,
        room = EXCLUDED.room
`

type CreateOrUpdateKnownCourseParams struct {
	Guid             string
	Name             string
	Period           sql.NullString
	Teacherfirstname sql.NullString
	Teacherlastname  sql.NullString
	Teacheremail     sql.NullString
	Room             sql.NullString
}

func (q *Queries) CreateOrUpdateKnownCourse(ctx context.Context, arg CreateOrUpdateKnownCourseParams) error {
	_, err := q.db.ExecContext(ctx, createOrUpdateKnownCourse,
		arg.Guid,
		arg.Name,
		arg.Period,
		arg.Teacherfirstname,
		arg.Teacherlastname,
		arg.Teacheremail,
		arg.Room,
	)
	return err
}

const createOrUpdateOAuthToken = `-- name: CreateOrUpdateOAuthToken :exec
insert into OAuthToken(studentId, token, expiresAt)
values (?, ?, ?)
on conflict (studentId) do update set
    token = EXCLUDED.token,
    expiresAt = EXCLUDED.expiresAt
`

type CreateOrUpdateOAuthTokenParams struct {
	Studentid string
	Token     string
	Expiresat int64
}

func (q *Queries) CreateOrUpdateOAuthToken(ctx context.Context, arg CreateOrUpdateOAuthTokenParams) error {
	_, err := q.db.ExecContext(ctx, createOrUpdateOAuthToken, arg.Studentid, arg.Token, arg.Expiresat)
	return err
}

const createOrUpdateStudentData = `-- name: CreateOrUpdateStudentData :exec
insert into StudentData(studentId, cached, createdAt)
values (?, ?, ?)
on conflict (studentId)
    do update set
        cached = EXCLUDED.cached,
        createdAt = EXCLUDED.createdAt
`

type CreateOrUpdateStudentDataParams struct {
	Studentid string
	Cached    []byte
	Createdat int64
}

func (q *Queries) CreateOrUpdateStudentData(ctx context.Context, arg CreateOrUpdateStudentDataParams) error {
	_, err := q.db.ExecContext(ctx, createOrUpdateStudentData, arg.Studentid, arg.Cached, arg.Createdat)
	return err
}

const createStudent = `-- name: CreateStudent :exec
insert into Student(id)
values (?)
on conflict (id) do nothing
`

func (q *Queries) CreateStudent(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, createStudent, id)
	return err
}

const deleteExpiredOAuthTokens = `-- name: DeleteExpiredOAuthTokens :exec
delete from OAuthToken
where expiresAt < ?
`

func (q *Queries) DeleteExpiredOAuthTokens(ctx context.Context, expiresat int64) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredOAuthTokens, expiresat)
	return err
}

const getExpiredTokens = `-- name: GetExpiredTokens :many
select studentid, token, expiresat from OAuthToken
where expiresAt < ?
`

func (q *Queries) GetExpiredTokens(ctx context.Context, expiresat int64) ([]OAuthToken, error) {
	rows, err := q.db.QueryContext(ctx, getExpiredTokens, expiresat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OAuthToken
	for rows.Next() {
		var i OAuthToken
		if err := rows.Scan(&i.Studentid, &i.Token, &i.Expiresat); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKnownCourses = `-- name: GetKnownCourses :many
select guid, name, period, teacherfirstname, teacherlastname, teacheremail, room from KnownCourse
`

func (q *Queries) GetKnownCourses(ctx context.Context) ([]KnownCourse, error) {
	rows, err := q.db.QueryContext(ctx, getKnownCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []KnownCourse
	for rows.Next() {
		var i KnownCourse
		if err := rows.Scan(
			&i.Guid,
			&i.Name,
			&i.Period,
			&i.Teacherfirstname,
			&i.Teacherlastname,
			&i.Teacheremail,
			&i.Room,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOAuthToken = `-- name: GetOAuthToken :one
select studentid, token, expiresat from OAuthToken
where studentId = ? limit 1
`

func (q *Queries) GetOAuthToken(ctx context.Context, studentid string) (OAuthToken, error) {
	row := q.db.QueryRowContext(ctx, getOAuthToken, studentid)
	var i OAuthToken
	err := row.Scan(&i.Studentid, &i.Token, &i.Expiresat)
	return i, err
}
