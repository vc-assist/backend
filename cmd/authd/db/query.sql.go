// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
)

const createToken = `-- name: CreateToken :exec
insert into ActiveToken(token, userEmail, expiresAt) values (?, ?, ?)
`

type CreateTokenParams struct {
	Token     string
	Useremail string
	Expiresat int64
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) error {
	_, err := q.db.ExecContext(ctx, createToken, arg.Token, arg.Useremail, arg.Expiresat)
	return err
}

const createVerificationCode = `-- name: CreateVerificationCode :exec
insert into VerificationCode(code, userEmail, expiresAt) values (?, ?, ?)
`

type CreateVerificationCodeParams struct {
	Code      string
	Useremail string
	Expiresat int64
}

func (q *Queries) CreateVerificationCode(ctx context.Context, arg CreateVerificationCodeParams) error {
	_, err := q.db.ExecContext(ctx, createVerificationCode, arg.Code, arg.Useremail, arg.Expiresat)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
delete from ActiveToken where token = ?
`

func (q *Queries) DeleteToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteToken, token)
	return err
}

const deleteVerificationCode = `-- name: DeleteVerificationCode :exec
delete from VerificationCode where code = ?
`

func (q *Queries) DeleteVerificationCode(ctx context.Context, code string) error {
	_, err := q.db.ExecContext(ctx, deleteVerificationCode, code)
	return err
}

const ensureUserExists = `-- name: EnsureUserExists :exec
insert into User(email) values (?)
on conflict do nothing
`

func (q *Queries) EnsureUserExists(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, ensureUserExists, email)
	return err
}

const getUserFromCode = `-- name: GetUserFromCode :one
select email from User
inner join (
    select code, useremail, expiresat from VerificationCode where code = ?
) as code on code.userEmail = User.email
`

func (q *Queries) GetUserFromCode(ctx context.Context, code string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserFromCode, code)
	var email string
	err := row.Scan(&email)
	return email, err
}

const getUserFromToken = `-- name: GetUserFromToken :one
select email from User
inner join (
    select token, useremail, expiresat from ActiveToken where token = ?
) as token on token.userEmail = User.email
`

func (q *Queries) GetUserFromToken(ctx context.Context, token string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserFromToken, token)
	var email string
	err := row.Scan(&email)
	return email, err
}
